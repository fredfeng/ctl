\documentclass{article}
%\documentclass[journal]{IEEEtran}
%\documentclass{report}
%\documentclass{acta}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage[ruled, vlined]{algorithm2e}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}{Example}
\newcommand*{\leadstostar}{\leadsto\hspace{-.14cm}\star\ }


\begin{document}

\title{Efficient Policy Enforcement in Android Applications with Counterexample-Guided Abstraction Refinement}
\author{Yu Feng}

\maketitle

\begin{abstract}
In our previous work, we presented Apposcopy~\cite{apposcopy}, a new semantics-based approach 
for identifying a prevalent class of Android malware that steals 
private user information. However, in practice, we also noticed 
that several malicious behaviors can only be triggered under a 
certain sequential system events and our current tool will generate 
several false positives in those cases. To detect such behaviors, 
one way is to perform model checking on the abstract state 
machine of a given Android application.
But the downside is that the system will take a longer time to analyze
a single application. 

To detect malware that violate the security policy specified by users 
in terms of temporal formulas in a efficient way, we apply 
counterexample-guided abstraction refinement-based(CEGAR) model 
checking. The intuition is, we build the TICCG(Temporal Inter-Component 
communication Call Graph) which is the abstract state machine of a given 
Android applicaton, then the system will check the validity of the application
with respect to a set of temporal properties. If it's valid, then 
our system satisfies current properties. If it's invalid, it could
be (1) a true violation, which we report it to the user; Or (2)
a false positive. In this case, we will refine the TICCG based on
the counterexample generated by the trace of system events.
\end{abstract}


\section{Introduction}
As the most popular mobile operating system, the Android platform 
is a growing target for  mobile malware.
Today, many of the malicious applications that afflict  Android users  exploit
the private and monetized information
stored in a user's smartphone, such as the user's contacts, photos, or
account information. 

To mitigate the above problems, researchers have been working on either 
static analysis-based techniques, such as semantic-based approaches and taint analysis, 
or dynamic analysis based on monitoring the execution traces of a 
given application. However, there are still corpus of malware that is hard to detect 
by existing technique. According to a recent literature~\cite{pegasus}, there are
several sophisticated Android malware and their malcious behaviors can only 
be triggered under a specific event sequences. Such malicious behaviors 
are difficult to categorize by simply checking whether they are stealing 
some sensitive informantion. Applications related to audio and video eavedropping 
belong to this spectrum: The malware will record audio and video information
without user's notice through a backgroud process. Traditional way to 
mitigate this problem is to mark both audio and video record as sensitive
data and perform a sound taint analysis on it. 
Unfortunately, since many benign apps  also need access to audio and video record 
to perform their advertised functionality, not every app that
leaks user information can be classified as malware. We need to figure out
a way to differentiate the benign and malicious behaviors to reduce false positives.

In response to the  rapid dissemination of 
Android malware, one alternative approach is to build an abstract
model for Android applications and perform model checking with respect
to the custom specification in the form of temporal formulas. 
Latest work like Pegasus\cite{pegasus} models Android applications as "Permission Event Graph"
and checking the safty properties encoded by Java program. While it can 
differentiate benign applicaton and malicious application through a set 
of safty properties, it also suffers the performance issue: Most of the 
applications will take more than 1000 seconds to terminate. 

The intuition behind our work is that not only do we need to detect
the difference between user expectation and malicious intent through the 
context where system's API and permissions are used during runtime like 
Pegasus~\cite{pegasus},  we should also apply the technique of  
counterexample-guided abstraction refinement-based(CEGAR) to reduce 
the overhead of model checking.

\subsection{Problem and Approach}
Here we describe the challenges behind our approaches in a bit more detail
as well as the insights behind our solutions.

{\bf \emph{Problem Definition}}. Here, we consider the following problems
which are closely related to each other. The first problem is how to design
a specification language to encode the semantic of the event-driven behaviors 
of Android System. Pegasus~\cite{pegasus} expresses the specification 
in terms of Java program and it is not very convenient and compact from the
perspective of the users; The second problem is how to contruct an abstract
model for the interaction between an Android application and the Android
core event system; The last problem is given an abstract model and a specification
in the form of temporal properties, how do we perform model checking efficiently.

{\bf \emph{Challenges}}. Our specification language should be able to 
express some custom security policies that monitor the usage of system API and 
permission in a concise and compact way. For instance, specifying a SMS messge
can not be sent if user does not press the 'SEND' button. Likewise, 
a Device ID can not be uploaded to a remote server if a confirmation 
dialog does not show and confirm by the user.

Even though model checking is a powerful technique for checking the temporal 
properties of Android application, the interaction between the Android application
and Android system is very complicated compared to normal Java program: 
It introduces several event-handler as well as  register-callback mechanisms
which are invisible to traditional control flow graph; To make thing harder, 
recent research show that static analysis of event-driven programs turn out 
to be EXPSPACE-hard~\cite{jhala2007}. So our first challenge is how to model the
interaction between Android application and Android core event system.

The second challenge is how do we design an abstraction that can reflect the 
event-driven behavior in Android application concisely. We do not want to 
model the entire Android system because it will be intractable. Moreover,
the usage of standard Java API and Android SDK makes the event system more complicated.

Now that we have both an abstract model for the Android application and 
a specification of the temporal properties, the third challenge is how to 
perform model checking efficiently. 

{\bf \emph{Insights}}. Our first insight is that even though the Android
event system is complicated, the total number of events and the number of 
API that will change the state of the abstract model is finite. Thus it is
feasible to design a specification language to express the temporal properties
with respect to some security policies. 

Our second insight is that to come up with an abstract model which reflects
the interaction between the Android application and the Android core event 
system, we use a graph to express it explicitly. More specifically, we 
design TICCG(Temporal Inter-Component Communication Call Graph), which is
an extension of our previous ICCG(Inter-Component Communication Call Graph)~\cite{apposcopy}.
More importantly, TICCG abstracts the interactions among the Android event
system, permissions and API usage in the application but ignore the low
level details which is irrelevant to our analysis.

Our third insight is to use the technique of the counterexample-guided 
abstraction refinement-based(CEGAR) to improve the performance of 
model checking. Recent research like JAM\cite{cegar12} introduces CEGAR 
to reduce the runtime overhead of web application in the context of 
Javascript, which is closed to our current work.
To the best of our knowledge, there is no previous model checking tools for 
Android applications which can scale in large applications.

\subsection{Content and Contributions}
The main contributions of this work can be summarized as follows.
% itemize
\begin{itemize}
\item {\bf \emph{TICCG}}, a new abstraction for Android application
that models the temporal behaviors of system APIs and system events;
\item {\bf \emph{Encoding benign and malicious intent}}, we provide a specification
language for user to express the temporal properties of TICCG; 
\item {\bf \emph{TICCG Construction and Analysis}}, we construct TICCG by combining 
traditionl static analyses technique(Pointer analysis, Call Graph construction, taint analysis, etc)
with the semantic of Android API, permission and event system. Then we implement
model checking on TICCG with respect to the specification;
\item {\bf \emph{CEGAR-based refinement}}, We apply the counterexample-guided 
abstraction refinement-based(CEGAR) technique in Android application 
and use it to improve the performance of the system dramatically.
\item {\bf \emph{Experiments}}, We run our tool on both some benign applications and 
malware to verify that our system can identify malicious behaviors precisely.
\end{itemize}

The paper is structured as follows: We first provide some background knowledge of
Android framework and illustrate our technique by a simple example in Section~\ref{sec:overview}.
Secondly we formalize the definition of TICCG in Section~\ref{sec:ticcg} and 
the algorithm to construct it in Section~\ref{sec:construct}. Third, 
we describe some details about our refinement with CEGAR in Section~\ref{sec:cegar}, 
followed by our preliminary evaluation in Section~\ref{sec:eval}.
Finally we conclude our work in Section~\ref{sec:conclude}.

\section{Background and Overview}
\label{sec:overview}
In this section, we will first introduce some basic knowledge of Android framework 
and then illustrate our approach using a simplified version of a malcious application.

\subsection{Android Background}
\begin{itemize}
\item {\bf \emph{Components}}. An Android application consists of four kinds of components, 
\emph{Activity}, \emph{Service}, \emph{BroadcastReceiver}, and \emph{ContentProvider}.
Activity components form the basis of the user
  interface, and each window of the application is typically controlled by
  an activity. Service components run in the background and remain active even
  if windows are switched. 
  %Services can expose interfaces for communication with other applications.
BroadcastReceiver components react asynchronously to messages
  from other applications. Finally, ContentProvider components store data relevant to the
  application, usually in a database, and allow sharing  data across applications.

\item {\bf \emph{Permissions}}. A security \emph{permission} that can be used to 
put the limitation on the access of some system resources. Typically, an application
needs specific permissions to access SMS message, contact list, SD card, etc.

\item {\bf \emph{Lifecycle methods}}. A special set of pre-defined methods which is used 
to manage the lifecycle of Android components. As a user navigates though, pause and switch
out of current application, different lifecycle methods will be invoked to switch the 
component to different states. For instance, an application might call \emph{startActivity}
to start an Activity. When the user switch out to other application and then switch back again,
\emph{onResume} method will be invoked by the Android system automatically.  

\item {\bf \emph{System APIs and Events}}. Those are two way for an application to communicate
with the Android system. A typical scenario in Android application is: the programmer will define
callbacks and add hook them up to some events through listeners. As soon as the event is fired, 
its corresponding callback method will be invoked by the Android system. For instance, 
SMS Received notification, Phone calls, etc.

\end{itemize}

\subsection{System Overview}
% Figure
\begin{figure}
\centerline{\includegraphics[scale=0.4]{sysgraph}}
\caption{System Overview}
\label{fig:one}
\end{figure}

Figure~\ref{fig:one} shows an overview of the system architecture.
It takes as input an Android application(source code or bytecode) 
and a set of temporal properties encoded as datalog. By running the 
abstract engine, the system first converts the Android application 
to TICCG(Temporal Inter-Component Communication Call Graph), 
which is the augmented version of our previous work\cite{apposcopy}
by modeling the system events and system APIs in the graph. 
Then the static verifier will perform stardard model checking to 
verify whether all the temporal properties are valid with respect 
to a given TICCG. If the result is valid and since our analysis is 
sound, we conclude that current application will not violate those
temporal properties. If the result is invalid, then there exists two
cases: (1) We detect a true violation and report it to the user; 
(2) It is a false positive because our analysis is imprecise or the 
given temporal formulas are too strong to exclude some benign applications.
For the first case, we will use current system event traces as a counterexample
\cite{clarkecegar} and  run the refiner to refine the original 
TICCG to prune the search space; For the second case, we can manully
modify the temporal formulas based on some domain specific information.

\subsection{Our approach by Example}
In the section we will briefly illustrate our approach using a simplified 
version of a malcious application.

Figure~\ref{dropcall} is a malware named "Drop Call" which is similar to
the example in Pegasus~\cite{pegasus}. It it a typical 
eavesdropping malware which records audios silently without interacting with the
User Interface of the application. If we mark audio record as sensitive data 
and perform traditional taint analysis in a naive way, we might also 
exclude a lot of legitimate applications. A typical benigh usage of this 
application should obey the following temporal properties: 
\begin{itemize}
\item {\bf \emph{Do not start recording util user clicks the 'Start' button}}. 
\item {\bf \emph{Do not start recording if user pressst the 'Stop' button}}. 
\end{itemize}
The above properties are the key to differentiate whether an application is 
benign or malcious under current context(audio recording). Moving forward,
we could formalize them in term of a logical formula:
\[
(\neg StartRecord \cup StartOnclick)    
\land (StopRecord \iff StopOnclick)    
\]

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.8]{dropped-call.jpg}
\caption{Drop Call example\label{dropcall}}
\end{figure}

We encode the benign user intent in the form of temporal formulas similar to 
above example and conclude that an application is very likely to be 
malicious if it violates the proterties during runtime. However, since we 
over-apprximate the behaviors of Android applications, it is possible that 
our system reports a false positive. In this case, we will generate a 
counterexample in the form of a sequence of execution states and let the auditor
to decide whether it is a false positive or a true violation. If it is a false
positive, we will use this counterexample to refine our search space thus
performing model checking efficiently.

Now we have the temporal property for the example application, the next 
challenge problem is, how do we design an abstraction for this 'Drop Call' 
application and perform model checking on it. Our abstraction should be large
enough to avoid too much false positives yet concise and compact enough 
to make the computation tractable.


{\bf \emph{Temporal Inter-Component Communication Call Graph}}. Even though
the total number of APIs in Android applications and Android framework is large,
the number of Android system APIs that modify the application states and 
interact with the permission system is much smaller. Inspired by Pegasus~\cite{pegasus} 
and another recent work~\cite{aware14}, we design the Temporal Inter-Component
 Communication Call Graph(TICCG), a new abstraction for 
Android applications as an extension of our previous work~\cite{apposcopy}.
More specifically, in TICCG, each node represents a state under certain
event context and each edge denotes certain callback methods will be invoked 
on that specific context. We also attach the semantic of system APIs 
as well as their corresponding permissions to the edge to categorize 
the transition precisely. We will describe the construction algorithm for 
TICCG in a bit more detail in Section~\ref{sec:ticcg} 

Once we finish constructing the TICCG for the example, the original temporal
properties can be viewed as queries on the properties of TICCG and we answer those
queries through model checking.  

\section{Our Abstraction for Android Applications}
\label{sec:ticcg}

\begin{figure}[ht!]
\centering
\includegraphics[width=10cm,height=6cm,keepaspectratio]{state.pdf}
\caption{TICCG for the running exampl\label{state}}
\end{figure}

In this section, we will formalize the definition of TICCG, which is our abstraction
for Android applications. We also briefly introduce the malware specification language
that is going to be used to encode the temporal properties.

\subsection{Definition of TICCG}
\begin{definition}
\vspace{-0.05in}
The Temporal Inter-Component Call Graph(TICCG) over a set of events and system APIs
is represented formally by a 4-tuple $(q_0,S,\tau,\pi)$, where:
\begin{itemize}
\item $q_0$ is a set of initial states;
\item $S$ is a set of abstract states which represent a set of runtime states;
\item $tau$ is a normal transition starting from current state $P$ and when an event
$e$ fires and its corresponding callback method $cb_1$ is invoked, the system will switch
to a new state $Q$;
\item $pi$ is an asynchronous transition from current state $P$ to a new state $Q$
labeled with a life-cycle method $m_1$.
\end{itemize}
\vspace{-0.05in}
\end{definition}

\begin{definition} 
\label{def:leadsto}
\vspace{-0.05in}
We write $m_1 \leadsto m_2$ iff method $m_1$ directly calls 
$m_2$ in some execution of the program. We define $\leadstostar$ to be the reflexive 
transitive closure of  $\leadsto$.
\vspace{-0.05in}
\end{definition} 


Figure~\ref{state} shows a partial TICCG for previous running example. Here, a dash line denotes
an asynchronous transition while a solid line represents a normal transition. The upper part of 
the figure means there is a asynchronous transition from $S_1$ to $S_2$ when the life-cycle method \verb+onResume()+ is invoked by the Android system; The lower part of the figure means if the application is currently in state $S_3$, after the \verb+Button.Onclick+ event is fired and its 
corresponding callback method \verb+onClick()+ is invoked, the application will switch to 
a new runtime state $S_4$.

Observe that TICCG is different from either Call graph or Control Flow Graph.
A Call Graph denotes the call relations among methods in the system while TICCG only concerns
about the methods that belong to the Android system; A Control Flow Graph represents the control
dependency among statements in a method whereas TICCG labels callback methods or system methods
that change the runtime states of the system. Intuitively, TICCG is a high-level abstraction
for the runtime states transition of the Android application.

\subsection{Malware Specification Language}
This section describes our malware signature language, which is a Datalog program augmented with 
built-in predicates. The user may also define 
additional helper predicates  used in encoding the temporal properties.
In what follows, we first give some background on Datalog, and then describe the 
 the syntax and semantics of our built-in predicates.


{\bf \emph{Datalog Preliminaries}}. 
A Datalog program  consists of a set of \emph{rules} and a set of \emph{facts}. 
Facts simply declare predicates that evaluate to true. For example, 
{\tt parent("Bill", "Mary")} states that Bill is a parent of Mary. Each  Datalog rule is  a Horn clause defining a predicate as a conjunction of other
predicates. For example, the  rule:

\begin{verbatim}
ancestor(x, y) :- parent(x, z), ancestor(z, y).
\end{verbatim}
\normalsize

\noindent
says that \verb+ancestor(x, y)+ is true if both \verb+parent(x, z)+ and
\verb+ancestor(z, y)+ are true. In addition to variables, predicates can 
also contain constants, 
which are surrounded by double quotes, or
``don't cares",  denoted by underscores.

Datalog predicates naturally represent relations. Specifically, if tuple $(x, y, z)$
is in relation $A$, this means the  predicate $A(x, y, z)$ is
true. In what follows, we write the type of a relation $R \subseteq X \times Y \times \ldots$ as $(s_1 : X, s_2 : Y, \ldots)$, where
$s1$, $s2$, $\ldots$ are descriptive texts for the corresponding domains.

Coming back to our system, the following code snippet is being used to implement the temporal
property in our previous motivation example for "Drop-Call".

\begin{verbatim}
function checkValidity(e)
    return function(e)
        if e="start"
            return true
        if e="stop"
            return false
        end
end
datalog.add_iter_prim("checkValidity")
\end{verbatim}
\normalsize

Here, the goal of function $checkValidify(e)$ is given a specific event, return $true$
if the argument is a "start" event and return $false$ otherwise. The last statement is to
add current procedure to the datalog database as a public API. 

However, it will be quite tedious if the auditor has to write such kind of 
program for each temporal property. To mitigate this problem, we automatically map
all system APIs to a set of their corresponding permissions based on previous result of
PScout~\cite{pscout}. Finally we generate the codes for checking the temporal properties 
based on the mapping.  

Similar to our previous work in Apposcopy~\cite{apposcopy}, TICCG also provides some 
build-in predicates to capture the semantic of Android application:
\begin{itemize}
\item {\bf \emph{flow predicate}}, specifying the data-flow properties such as whether 
there is a flow from the device Id to Internet;
\item {\bf \emph{ICC predicate}}, specifying the control-flow properties such as
whether an Activity $A$ could launch a service $B$.
\end{itemize}



\section{TICCG Construction}
\label{sec:construct}
In this section, we will describe the algorithm to contruct the TICCG. 

{\bf \emph{Pointer analysis and Callgraph Construction}}. In order to build the temporal inter-component callgraph and track information flow, our system starts by performing a pointer analysis, 
which computes the set of abstract heap objects that each variable may point to. In the remainder of the paper, we use the notation 
 $v \hookrightarrow o$ to denote  that 
variable $v$ may point to an abstract heap object  represented by  $o$ in some execution of the program. 



Since the precision of the underlying pointer analysis  is critical for detecting malware with few false alarms, 
we use a field- and context-sensitive Andersen-style pointer analysis~\cite{andersen}. For context-sensitivity, we use a hybrid approach
that combines call-site sensitivity~\cite{kcfa} and object-sensitivity~\cite{MilanovaRR05}. 
In particular, our approach is  similar to the technique described in~\cite{hybrid-context} and uses
call-site sensitivity for static method calls and object-sensitivity for virtual method calls. 

Another key ingredient of our  malware detection algorithm is callgraph construction, which is used for resolving the 
targets of virtual method calls. Since callgraph precision  has significant impact on the precision of the TICCG, 
our system computes the callgraph on-the-fly, simultaneously refining the targets of virtual method calls and points-to sets  until a fixed point is reached. The set of edges in the resulting callgraph represent the relation $\leadsto$ from
Definition~\ref{def:leadsto}. An edge in the callgraph from method $m_1$
to  method $m_2$ corresponds to $m_1 \leadsto m_2$.
Similarly, $m_1 \leadsto m_2$
represents that there exists a path in the callgraph from 
$m_1$ to  $m_2$.


{\bf \emph{Event Context Extraction}}. 
The goal of event context extraction is to generate the precondition for the handler to execute given the name of the event handler as the input. For instance, an event handler named \verb+Button.onClick+ will eventually invoke the \verb+onClick()+ callback in the application. More specifically, we use previous points-to information to keep tracking the actual argument of listener methods that build connections between events and their corresponding callback methods. In figure~\ref{onclick}, based on the points-to information, we infer that   
the user declares a customized callback method(\verb+onClick()+) and hooks it up with a button labeled with \verb+'clickMe'+ through the system API \verb+setOnclickListener+. If we use a naive or imprecise pointer analysis, it will conclude that every callback method will be hook up with every event named \verb+'onClick'+ thus generate a lot of false positives. 
\begin{figure}[!t]
\begin{center}
{ 
\begin{verbatim}
1.Button btn = (Button)findViewById("clickMe");
2.// Register the onClick listener with the implementation above
3.buttonX.setOnClickListener(new OnClickListener() {
4.    public void onClick(View v)
5.    {
6.        sendSMS();
7.    } 
8.});
\end{verbatim}
}
\end{center}
\caption{Code Snippet for event registration.}
\label{fig:onclick}
\end{figure}


{\bf \emph{System APIs Semantic Analysis}}. 
The goal of the system APIs semantic analysis is the following: given the precondition as well as the name of a event handler as an input, generate the postcondition for which the method is going to be invoked. For instance, the handler named \verb+onResume+ will invoke the \verb+onResume()+ method in $android.app.Activity$ class. 
During implementation, we do not analyze the source codes of Android APIs but writing models based on manually checking their semantic. Our system's static analyses use manually-written models of the Android framework; currently, we have models for about
1,100 classes that are relevant for our analyses.


\section{Abstract Refinement}
\label{sec:cegar}
In this section, we will describe the algorithm to perform model checking efficiently
by applying CEGAR.

Algorithm~\ref{alg:abs} shows the key idea for performing model checking on a given program $P$
 with respect to a set of temporal properties $\Phi$. The algorithm takes a program $P$, a set of temporal formulas$\Phi$, a finite set of predicates and a bound $k$ to restrict the maximum 
 number of predicates in the formulas. The algorithm begins with modeling a sound abstraction for Program $P$. In current context, the abstraction denotes the symbolic representation of TICCG.
 
 The algorithm first searchs for a path from initial state to final states which violate the 
 given temporal properties. If it eventually finds such a path($\pi$), its next step is to
whether $\pi$ is an actual violation or false positive. If it's an actuall violation, then our system will report a violation with this counterexample; If it's a false positive, then our system
needs to perform abstract refinement on current predicates set until (i). The actuall violation is exposed; (ii) The size of predicates reaches the bound($k$).  

More specifically, if the counterexample $\pi$ is not an actual violation with respect to 
the given temporal properties and it has a size of predicates less than $k$, the algorithm will 
refine current predicates set $E$ by learning new predicates by function $getNewProdicate(\pi)$
 from current counterexample. Otherwise, a violation will be reported.

Next we will go through some key procedures step by step:

{\bf \emph{Abstraction ($abstract(P)$)}}. Given a set of predicates $E$ and an Android program
$P$, the goal of function $abstract(P)$ is to produce $P_A$, which is the symbolic version of
$P$ with equivalent semantic. Based on previous introduction, $P_A$ is actuall an automaton 
corresponding to TICCG.

{\bf \emph{Reachability Checking ($getReachable(P,E)$)}}. Given the abstract version of TICCG 
for the Android program $P$ and predicates $E$, the goal of $getReachable(P,E)$ is to search
all the possible pathes that violate the temporal properties $\Phi$. Since we also represent 
the temporal properties $\Phi$ with automatons $G_{\Phi}$, the reachability checking problem can reduce to verifying whether the intersection between $G_{\Phi}$ and $P_A$, if it is not empty,
a counterexample corresponds to the trace($\pi$) will be reported.

{\bf \emph{Validity Checking ($isValid(\pi)$)}}. The procedure for validity checking is to 
verify whether the counterexample $\pi$ is an actual path in through program $P$. This is 
a common problem which had been solved by most model checkers~\cite{slam,lazy02}. The key idea is to construct 
a formula $F$ with the property that $\pi$ is an actual path if and only if $F$ is valid.

{\bf \emph{Abstract Refinement ($getNewPredicate(\pi)$)}}. Since our $P_A$ will always be
 an over-approximation to the actual program $P$, given a counterexample $\pi$,  there could 
exist two cases: (i). The formula $F$ corresponding to $\pi$ is valid and $\pi$ is indeed a 
violation; (ii). $F$ is invalid, which means that we can not conclude that $\pi$ is the actual 
violation. In this case, if the algorithm has not reach the bound $k$, it will invoke 
$getNewPredicate(\pi)$ to add new predicates $E_A$ to current predicates set. In our implementation we use interpolation~\cite{mcmillan05} to compute $E_A$.

{\bf \emph{Violation witness $\Upsilon$}}. 
In many cases, even though our tool detects the violation statically, the human auditors 
still want to construct the specific input to reproduce the violation so as to double confirm
that it is indeed a violation. In our system we implement violation witness to achieve this
goal. The term \emph{violation witness} is inspired from a recent work~\cite{cegar12}. 
It is a sequnce of statements $\Upsilon^{\Phi}_{\pi}$ in current program $P$ with respect to the counterexample $\pi$ and temporal properties $\Phi$. We do not discuss the detail computaion for  
$\Upsilon^{\Phi}_{\pi}$ here, but the intuition is given a counterexample $\phi$ as well as
the temporal properties $\Phi$, there must exit a sequence of statments $s_0, s_1, ..., s_n$
from initial state to final state.

{\bf \emph{Termination}}. 
Our algorithm is guaranteed to terminate because of those two properties: (i). It performs a
 bounded model checking with respect to a maximum number of $k$ predicates; (ii). In the worst
 case, it will report violation for every statment, which is also a finite set.


\begin{algorithm}[!t]
\label{fig:alg}
\SetAlgoLined
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\Input{Current Program $P$,  maximum number of predicates $k$, 
    a set of temporal properties$\Phi$, predicates set $E$}
\Output{A set of counterexamples which violates the given temporal properties.}
\Repeat{forever}{
    $P_{A} \leftarrow$ $Abstract(P,E)$\\
    $\pi \leftarrow$ $getReachable(P,E)$

    \uIf{$\pi == null$} {
        return
    }
    \uElseIf{$isValid(\pi)$} {
        report properties violation.\\
        $report(\pi, \Phi)$\\
        return
    }
    \Else{
    //Refine current abstraction with bounded model checking through a maximum number of k predicates.\\
        \uIf{$|E| < k$}{
            $E \leftarrow$ $E\cup getNewPrdicate(\pi)$
        } 
        \Else{
            //reach the limit of k. report anyway.\\
            report properties violation\\
            $report(\pi, \Phi)$\\
            return
        }

    }
}
\caption{Abstract refinement with respect to temporal properties}\label{alg:abs}
\end{algorithm}


\section{Evaluation}
\label{sec:eval}
In this section, we will show some preliminary result of our tool on both benign
applications and malware. Since we do not have enough time to finish all the implementation of 
this course project as well as the experiments before the deadline, 
I am going to briefly outline the design of our experiments.

Basically we want to perform an apple-to-apple comparison with Pegasus~\cite{pegasus}.
In Pegasus'~\cite{pegasus} paper, the authors ran  it on 152 malicious and 117 benign 
Android applications from Google Play. More specifically, they performed both
Generic Specification checking and Application-Specific Properties checking separately.
Here, we are very interested in the results of Generic Specification checking on our
tool, because such kinds of checkings could be fully automatic and Pegasus~\cite{pegasus}
yielded very bad performance in this experiment: It took an average of 2 hours in
abstraction phase and 1000 seconds for model checking. By applying CEGAR, we expect that
there will be a significant improvement in terms of the performance in model checking.
Since our TICCG only captures the high-level semantic of Android applications, we also
expect an improvement of performance in the abstraction phase. 

On the other hand, we also concern about the precision of TICCG over Pegasus. More 
specifically, we are going to evaluate the precision in two aspects:  
\begin{itemize}
\item In Pegasus' original test suites, TICCG should get better or same precision as 
Pegasus;

\item We also need to include more applications to demonstrate that TICCG yields 
better precision since it has richer semantic for Android applications.
\end{itemize}

We mark the evaluation section as future work.


\section{Conclusion}
\label{sec:conclude}
This is a blueprint version of the conclusion since we have not finished current work yet.

\begin{itemize}
\item We come up with {\bf \emph{TICCG}}, a new abstraction for Android application
that models the temporal behaviors of system APIs and system events. Since TICCG focuses
on high-level semantic of Android applications, our abstraction for Android application
is pretty compact;
\item {\bf \emph{Encoding benign and malicious intent}}, we provide a specification
language for user to express the temporal properties of TICCG; 
\item {\bf \emph{TICCG Construction and Analysis}}, we construct TICCG by combining 
traditionl static analyses technique(Pointer analysis, Call Graph construction, taint analysis, etc)
with the semantic of Android API, permission and event system. Then we implemen
model checking on TICCG with respect to the specification;
\item {\bf \emph{CEGAR-based refinement}}, our work is the first to apply the counterexample-guided abstraction refinement-based(CEGAR) technique in Android application 
and use it to tackle the performance issue. 
\item {\bf \emph{Experiments}}, We run our tool on both benign applications and 
malware and compare them with Pegasus. The result shows that our system can identify malicious behaviors precisely with less overhead.
\end{itemize}


% Bibliography
%\bibliographystyle{ACM-Reference-Format-Journals}
%\bibliography{mybib}
\bibliography{ctl}
\bibliographystyle{plain}
 

\end{document}
